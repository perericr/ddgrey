#!/usr/bin/perl -w
# dynamic greylisting status listing tool

use strict;
use 5.014;
use utf8;
# automatic USELIB

use Carp;
use Data::Dumper; # DEBUG
use Getopt::Long;
use IO::Socket;
use POSIX qw(setsid);
use DDgrey::Perl6::Parameters;

use DDgrey::MainConfig;
use DDgrey::Dispatcher;
use DDgrey::Policy;
use DDgrey::Select;

sub lm;
sub error;
sub calc_report;
sub report;
sub remove;

# ---- init ----

our $debug=0;
our $dir;

my $version='__VERSION__';
my $show={};
my $scores;
my $calc;
my $remove;

# -- fetch arguments --

Getopt::Long::Configure qw(bundling no_ignore_case);
GetOptions(
    # s=ddgrey [ip|domain] - list dynamic greylisting policy
    # l=commands
    # include=help-version
    # begin genop generated section
    'h|help'=>sub{
    	print "ddgrey [ip|domain] - list dynamic greylisting policy\n";
    	print "\n";
    	print "commands:\n";
    	print "-h --help    show this help text\n";
    	print "-V --version show version\n";
    	print "-r --remove  remove policy\n";
    	print "-c --calc    calculate policy\n";
    	print "\n";
    	print "options:\n";
    	print "-w --white   show whitelist\n";
    	print "-g --grey    show greylist\n";
    	print "-b --black   show blacklist\n";
    	print "-s --scores   show scores\n";
    	print "-d --debug   increase debug information\n";
    	print "-D --dir <D> look for config and other files in <D>\n";
    	exit 0;
    },
    'V|version'=>sub{print "$version\n";exit 0},
    # end genop generated section
    'r|remove'=>\$remove,       # remove policy
    'c|calc'=>\$calc,           # calculate policy
    
    # l=options
    'w|white'=>\$show->{white}, # show whitelist
    'g|grey'=>\$show->{grey},   # show greylist
    'b|black'=>\$show->{black}, # show blacklist
    's|scores'=>\$scores,       # show scores
    'd|debug'=>sub{$debug++},	# increase debug information
    'D|dir=s'=>\$dir,	        # look for config and other files in <D>
    ) or error("bad command line");

my $host=shift();

# read configuration
our $config=DDgrey::MainConfig->new();

# get user id
our $uid=undef;
our $gid=undef;
if($< == 0){
    my $user=$config->{user} // '_RUNUSER_';
    (undef,undef,$uid,$gid)=getpwnam($user);
    defined($uid) or main::error("error: no such user $user");
};

# -- start select --
our $select=DDgrey::Select->new();

# -- start store --
use DDgrey::DBStore qw($db);
our $store=DDgrey::DBStore->init();

# ---- main ----

# gör where-satser för show
my $where_report=[];
my $where=[];
my $args_report=[];
my $args=[];

my @show=();
if(keys %$show){
    $show->{black} and push @show,'black IS NOT NULL';
    $show->{grey} and push @show,'grey IS NOT NULL';
    $show->{white} and push @show,'(grey IS NULL and black IS NULL)';
}
if(@show){
	push @$where,'('.join(' OR ',@show).')';
};
if(defined($host)){
    if($host=~/^[\d\.]+$/){
	push @$where_report,"ip LIKE ?";
	push @$where,"ip LIKE ?";
	push @$args_report,"$host%";
	push @$args,"$host%";
    }
    else{
	push @$where_report,"domain=?";
	push @$where,"domain=?";
 	push @$args_report,$host;
 	push @$args,$host;
    };
};

# raderar först
if($remove){
    remove($where,$args);
};

# beräkna om önskat och kör sen rapport
if($calc){
    calc_report($where_report,$args_report,$where,$args);
}
else{
    report($where,$args);
};

# ---- functions ----

sub remove($where,$args){
    $db->query('delete from policy '.(@$where ? 'where ('.join(' AND ',@$where).') ' : ''),@$args);
};

sub calc_report($where_report,$args_report,$where,$args){
    # effekt: print report for hosts in domain, calculate if missing
    my @ips=$db->query_all_one('select ip from report '.(@$where_report ? 'where ('.join(' AND ',@$where_report).') ' : '').' group by ip order by ip',@$args_report);
    my $done={};
    for my $ip (@ips){
	$done->{$ip}=undef;
    };
    for my $ip (@ips){
	if($main::select->load()){
	    sleep 1;
	};
	DDgrey::Policy->ensure_policy($ip,sub{calc_report_done($where,$args,$ip,$done)});
	$select->run_once(0);
    };
    if(@ips){
	$select->run();
    }
    else{
	report($where,$args);
    };
};

sub calc_report_done($where,$args,$ip,$done){
    # effekt: kör report med  where och args om alla ip i done
    #         är markerade som klara. markerar ip som klar

    $done->{$ip}=1;
    if(not grep {!defined($done->{$_})} keys %$done){
	report($where,$args);
	$select->exit();
    };
};

sub report($where,$args){
    # effect: print reports matching where and args
    print head();
    for my $proto ($db->query_all('select * from policy '.(@$where ? 'where ('.join(' AND ',@$where).') ' : '').' order by domain,ip',@$args)){
	print protofm($proto);
    };
};

sub head(){
    # return: report header
    if($scores){
	return
	    "domain          ip              sc   status   reason\n".
	    "-------------------------------------------------------------------------------\n";
    }
    else{
	return
	    "domain          ip              status   reason\n".
	    "--------------------------------------------------------------------------\n";
    };
};

sub protofm($proto){
    # return: proto as a line for report

    my $s='';
    my $w;
    if(defined($proto->{black})){
	$w="black";
    }
    elsif(defined($proto->{grey})){
	$w="grey ".deltafm($proto->{grey});
    }
    else{
	$w="white";
    };
    $s.=sprintf('%-15s',$proto->{domain})." ";
    $s.=sprintf('%-16s',$proto->{ip});
    if($scores){
	$s.=sprintf('%-5s',$proto->{score});
    };
    $s.=sprintf('%-9s',$w);
    $s.=$proto->{reason};
    $s.="\n";
};

sub deltafm($s){
    # return: interval s as human readable string
    if($s < 60*60){
	return sprintf('%2u',int($s/60)).'m';
    }
    else{
	return sprintf('%2u',int($s/(60*60))).'h';
    };
};

sub lm($m){
    # effect: log message m
    warn "$m\n";
    return 1;
};

sub error($m;$system){
    # effect: log message m, die
    $system and $m="$system: $m";
    die "$m\n";
};
